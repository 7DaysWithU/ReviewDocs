# 栈、队列、串、数组与特殊矩阵

## 1 知识点

### 1.1 栈

* 定义：只能在一端进行操作的线性表
* 操作特性：Last In First Out，LIFO
* 存储
  * 顺序栈
    * 初始：`top = -1`
    * 入栈：`top += 1, stack[top] = element`
    * 出栈：`top -= 1`
    * 栈满：`top == max_size - 1`
    * 栈空：`top == 0`
    * 栈长：`top + 1`
  * 共享栈(特殊的顺序栈)
    * 一个栈底为`0`，另一个栈底为`max_size - 1`
    * 栈满：`top_0 + 1 == top_1`
  * 链栈
* ***入栈出栈顺序***
  * 卡特兰数：当  $n$  个不同元素入栈时，出栈元素不同排列个数为  $\dfrac{1}{n+1}C^n_{2n}$
* ***括号匹配***
  * 初始设置空栈，顺序读入括号
  * 如果读到左括号直接入栈
  * 如果读到右括号则检查栈顶元素是否与当前右括号匹配(如"("与")"、"["与"]"等)
  * 依次循环读入。若读入结束后栈非空则括号不匹配。否则括号匹配
* ***后缀表达式及其计算***
  * 后缀表达式构建
    * 遇到操作数直接加入后缀表达式
    * 遇到左括号直接入栈
    * 遇到右括号不入栈，持续弹出栈内运算符到后缀表达式中，直到遇到左括号。再直接弹出左括号
    * 遇到操作符，持续弹出栈内元素，直到栈顶元素是左括号或者栈顶元素的运算优先级小于当前运算符的优  先级或者栈空。再把当前操作符入栈
    * 循环上述操作，当表达式扫描完毕后，将栈内剩余运算符弹出到后缀表达式中
  * 后缀表达式计算
    * 初始化设置空栈，扫描后缀表达式，遇到操作数直接入栈
    * 遇到操作符则从栈中 ***先后*** 弹出操作数`A`和`B`,计算`B <operate> A`，运算结果入栈
    * 重复上述操作，当栈内只有一个元素时，该元素为后缀表达式的计算结果。否则说明后缀表达式错误
* ***递归栈帧***

### 1.2 队列

* 定义：只能在一端进行插入、一端进行删除的线性表
* 操作特性：First In First Out，FIFO
* 存储
  * 顺序队列
    * 初始：`front = rear = 0`
    * 入队：`queue[rear] = element, rear += 1`
    * 出队：`front += 1`
  * 循环队列
    * 初始：`front = rear = 0`
    * 入队：`queue[rear] = element, rear = (rear + 1) % max_size`
    * 出队：`front = (front + 1) % max_size`
    * 队长：`(rear - front + max_size) % max_size`
    * 特殊标识
      * 保留一个存储单元用于区分队满队空
        * 队空：`rear == front`
        * 队满：`(rear + 1) % max_size == front`
      * 队列数据类型增加`size`表示元素个数
        * 队空：`size == 0 and rear == front`
        * 队满：`size == max_size and rear == front`
      * 队列数据类型增加`tag`，插入元素成功则`tag = 1`，删除元素成功则`tag = 0`
        * 队空：`tag == 0 and rear == front`
        * 队满：`tag == 1 and rear == front`
  * 链队
    * `front`指针指向队头，`rear`指针指向队尾
    * 链表不带头结点时队空：`front == NULL and rear == NULL`
* 双端队列
  * 两端都可以进行插入和删除操作的线性表，且两端地位平等
  * 输出受限的双端队列
    * 两端都能插入，但只能一端删除
  * 输入受限的双端队列
    * 两端都能删除，但只能一端插入
* ***入队出队顺序***
* ***层次遍历***
  * 二叉树遍历
  * 广搜
* ***缓冲区***
  * 打印机进程缓冲池
  * CPU算力分配缓冲池

### 1.3 串

* 定义：由0个或多个字符组成的有限序列
* 存储
  * 顺序表
  * 堆分配(malloc、free)
  * 块链：在链表的基础上每个节点存放多个字符，称为块
* 模式匹配
  * BF朴素暴力
    * $O(mn)$ ， $m$ 为主串长度， $n$ 为模式串长度
    * 一旦失配，主串指针倒退
  * KMP算法
    * $O(m+n)$ ， $m$ 为主串长度， $n$ 为模式串长度
    * 求`next`数组(串以1为起始下标)
      * `next[1] = 0`
      * `j > 1`时，若前后缀满足`len(t[1:k + 1]) == len(t[j - k:j])`，其中`k = range(0, j - 1)`，则`next[j] = k + 1`
      * 若以0为串的起始下标，则`next`数组整体减`1`即可
    * 求`nextval`数组(串以1为起始下标)
      * `nextval[1] = 0`
      * `j > 1`时，`nextval[j] = nextval[next[j]] if t[j] == t[next[j]] else next[j]`
    * `KMP`匹配
      * 匹配：`i++，j++`
      * 失配：`i = i，j = next[j] or j = nextval[j]`
      * 成功找到：`j > len(t)`

### 1.4 数组与特殊矩阵

* 数组
  * 定义： n个相同类型的数据元素构成的有限序列
  * 一维数组存储：`元素地址 = 起始地址 + 元素下标 * 元素大小`
  * 二维数组存储
    * 行优先：`元素地址 = 起始地址 + ((前i - 1行) * 列数 + j) * 元素大小`
    * 列优先：`元素地址 = 起始地址 + ((前j - 1列) * 行数 + i) * 元素大小`
* 特殊矩阵
  * 对称矩阵
    * 上三角与下三角相同，只存一半
    * 确定行优先列优先，配合等差数列求元素位置
  * 三角矩阵
    * 上三角或下三角有一半是常量`c`
    * 采用对称矩阵的存储方式，额外在一维数组末尾增加一个空间记录常量`c`
  * 三对角矩阵(带状矩阵)
    * $\lvert i-j\rvert>1$ 时， $a_{i,j}=0$
    * 按行优先
      * 前`i - 1`行有`3(i - 1) - 1`个元素
      * $a_{i,j}=0$ 是第`i`行第`j - i + 2`个元素
      * $a_{i,j}=0$ 是第`(3(i - 1) - 1) + (j - i + 2)`个元素
  * 稀疏矩阵
    * 三元组`(i, j, element)`
    * 十字链表

## 2 题目

* 3.1习题
  * 10(链栈插入元素)
  * 26(出栈顺序)
  * 29(出栈顺序)
* 3.3习题
  * 06(递归粗疏)
* 3.2习题
  * 06(队列长度)
  * 08(循环队列判空)
  * 21(循环队列指针指向)
* 4.2习题
  * 08(KMP比较次数)
  * 12(KMP比较次数)
* 3.4习题
  * 03(对称矩阵元素索引)
  * 06(三对角矩阵元素索引)
