# 树、二叉树、森林

## 1 知识点

### 1.1 树

* 定义：树是有 $n(n\geq0)$ 个结点的有限集。 $n=0$ 时为空树
  * 有且仅有一个根结点
  * $n>1$ 时，其余个结点可分为 $m(m\geq0)$ 个互不相交的有限集。每个集合本身又是一颗树，称为根的*子树*
  * 根结点没有前驱；除根结点外每个结点有且仅有一个前驱
* 基本术语
  * 祖先：结点`K`到根结点的路径上除`K`外的所有结点均为`K`的祖先
  * 子孙：结点`K`到叶结点的路径上除`K`外的所有结点均为`K`的子孙
  * 双亲：结点`K`到根结点的路径上离`K`最近的祖先
  * 孩子：结点`K`到叶结点的路径上离`K`最近的子孙
  * 兄弟：有相同双亲的结点互为兄弟结点
  * 堂兄弟：在树的同一层的结点互为堂兄弟节点
  * 结点的层次(深度)：从根节点开始算，根节点为第1层，以此类推
  * 树的高度：树的最大层数
  * 度：结点的孩子数量即为结点的度数。树的度为`max(所有结点的度)`
  * 分支结点：`度 > 0`的结点
  * 叶结点：`度 == 0`的结点
  * 有序树：树中各结点的子树从左到右存在顺序，不能互换。反之为无序树
  * 路径：结点`A`与结点`B`之间的路径由`A`和`B`之间经过的结点序列构成
  * 结点的路径长度：路径上经过的边的个数
  * 树的路径长度：所有结点路径长度的总和
  * 森林：森林是 $m(m\geq0)$ 个互不相交的树的集合。若增加一个结点并使这 $m$ 个树作为该结点的子树，则该森林变成了树
* 性质
  * 树的性质
    * 树的结点数 $n$  = 所有结点度数和 + 1
    * 树的边数 $m$  =  $n-1$
    * $m$ 度树第 $i$ 层最多有 $m^{i-1}$ 个结点
    * 高 $h$ 的 $m$ 叉树最多有 $\dfrac{1\cdot(1-m^h)}{1-m}$ 个结点。(等比数列求和)
    * $n$ 个结点的 $m$ 度树最小高度为 $\lceil\log_m{(n(m-1)+1)}\rceil$
    * $n$ 个结点的 $m$ 度树最大高度为 $n-1+m$
    * 高 $h$ 的 $m$ 度树至少有 $h-1+m$ 个结点
* 存储 $\big($ 树与森林 $\big)$
  * 双亲表示法
    * 在线性表中使用`(data: Any, parent: int)`二元组表示每个结点。`data`表示结点的值，`parent`表示结点的双亲下标
    * 找双亲容易，找孩子难
  * 孩子表示法
    * 在线性表中使用`(data: Any, children: list[tuple[int, *]])`二元组表示每个结点。`data`表示结点的值，`child`链表表示结点的孩子们，每个孩子用一个二元组`(index: int, next: *)`来表示。`index`为孩子结点在线性表中的下标，`next`指针指向当前结点的下一个孩子结点
    * 找孩子容易，找双亲难
  * 孩子兄弟表示法
    * 使用链表表示，每个结点用三元组`(data: Any, first_child: *, first_brother: *)`表示。`data`为结点的值，`first_child`指针指向结点的第一个孩子，`first_brother`指针指向结点的第一个兄弟(从当前结点往右数第一个兄弟)。
    * ***左孩子右兄弟(树与森林转换用)***
    * 存储森林时，每棵树的根节点为平级关系
* 遍历
  * 树
    * 先根遍历：先访问根结点，再依次访问孩子结点
      * 访问顺序等同于将树或森林转化为二叉树后使用 ***先序遍历*** 的顺序
    * 后根遍历：先依次访问孩子结点，再访问根结点
      * 访问顺序等同于将树或森林转化为二叉树后使用 ***中序遍历*** 的顺序
    * 层次遍历：使用队列将根结点入队，每次出队时，将出队结点的孩子全部入队
  * 森林
    * 先序遍历：等同于依次先根遍历每棵树；或先将森林转化为二叉树，然后使用先序遍历
    * 中序遍历：等同于依次后根遍历每棵树；或先将森林转化为二叉树，然后使用中序遍历

### 1.2 二叉树

* 定义：特殊的树，每个结点至多只有两棵子树，***且子树有左右之分，不能交换顺序***
* 特殊二叉树
  * 满二叉树
    * 高度为 $h$ 且有 $2^h-1$ 个结点的二叉树称为满二叉树
    * 所有的叶结点都在最后一层
  * 完全二叉树
    * 当且仅当每个结点都与高度为 $h$ 的满二叉树中编号 $1$ ~ $n$ 的结点一一对应时为完全二叉树
    * 所有的叶结点都在最后两层
    * ***最多只有一个 $1$ 度结点***
    * $n=n_0+n_1+n_2=0\cdot n_0+1\cdot n_1+2\cdot n_2+1$
    * 第 $i$ 层最多有 $2^{i-1}$ 个结点
    * 高 $h$ 的二叉树最多有 $2^h-1$ 个结点
    * $id\leq\lfloor n/2\rfloor$ 的结点都是分支节点，取等号时为最后一个分支结点。大于时为叶结点
    * 若结点 $i$ 为叶结点或只有左孩子，则 $id>i$ 的结点都是叶节点
    * 若结点编号为 $i$ ，则左孩子编号为 $2i$ ，右孩子编号为 $2i+1$ ，双亲编号为 $\lfloor i/2\rfloor$
    * $n$ 个结点的完全二叉树高度为 $\lceil\log_2{(n+1)}\rceil$ 或 $\lfloor\log_2{n}+1\rfloor$
  * 二叉排序树
    * 左子树的 $key<$ 根结点的 $key$ ，右子树的 $key>$ 根节点的 $key$ ，递归构建树
  * 平衡二叉树
    * 二叉排序树的基础上，左右子树的高度差 $<1$
  * 正则二叉树
    * 每个分支结点都有2个孩子
    * 树中只有0度结点和2度结点
* 存储
  * 顺序存储
    * 一维数组
      * 结点下标实际按照 ***完全二叉树下标对应关系*** 存储，结点的值与下标是两个变量，即使结点不存在也要开辟空间
  * 链式存储
    * 二叉链：左孩子指针、右孩子指针
      * 二叉树二叉链空置 $2n-(n-1)=n+1$ 个指针
    * 三叉链：左孩子指针、右孩子指针、双亲指针
      * 二叉树三叉链空置 $3n-(n-1)-(n-1)=n+2$ 个指针
      * 三叉树三叉链空置 $3n-(n-1)=2n+1$ 个指针
* 遍历
  * 遍历方式
    * 先序遍历
      * 根左右(NLR)
      * 用于遍历运算树得到的是前缀表达式
    * 中序遍历
      * 左根右(LNR)
      * 用于遍历运算树得到的是中缀表达式
    * 后序遍历
      * 左右根(LRN)
      * 用于遍历运算树得到的是后缀表达式
    * 层次遍历
      * 根结点入队，每次出队时，将出队结点的孩子全部入队
      * 借助队列实现
  * 由遍历序列构造二叉树
    * 通过不同序列对照的方式逐层确定根结点、左子树、右子树
      * 先序遍历：`根(左子树)(右子树)`
      * 中序遍历：`(左子树)根(右子树)`
      * 后序遍历：`(左子树)(右子树)根`
      * 层次遍历：`根(左子树根)(右子树根)(左子树)...(右子树)`
    * 中序遍历 $+$ 其他任何一种方式均能唯一确定一棵二叉树。没有中序遍历序列不能唯一确定一棵二叉树
    * 前序序列与中序序列的关系等同于 ***以前序序列作为入栈顺序，以中序序列作为出栈顺序***
  * ***线索二叉树***
    * 定义：在原本二叉链表的基础上，增加`ltag`和`rtag`用于指示是否线索化。若`ltag = 0`则表示`lchild`指向的是左孩子；`ltag = 1`则表示`lchild`指向的是根据具体的遍历方式构成的序列中该结点的前驱结点。`rtag`同理
    * 构建线索二叉树框架同遍历，仅需修改对根结点的操作即可
      * 构建先序线索二叉树时需要判断`ltag == 0`。因为先序遍历先操作根结点再操作左子树，但操作根节点时可能需要修改左子树的`前驱指针`，之后若操作完根节点去操作左子树时可能出现需要操作根节点的`后继指针`，出现死循环
    * 后序线索二叉树的遍历需要栈的支持
    * ***前驱与后继线索***

      ||先序|中序|后序|
      |:-:|:-:|:-:|:-:|
      |**前驱**|如果是根节点，则没有前驱</br></br>如果是左孩子，则为父节点(需要三叉链表)</br></br>如果是右孩子且左子树为空，则为父节点(需要三叉链表)</br></br>如果是右孩子且左子树不为空，则为先序遍历左子树的最后一个结点|左子树最右下结点|有右孩子则为右孩子</br></br>没有右孩子则为左孩子|
      |**后继**|有左孩子则为左孩子</br></br>没有左孩子则为右孩子|右子树最左下结点|如果是根节点，则没有后继</br></br>如果是右孩子，则为父节点(需要三叉链表)</br></br>如果是左孩子且右子树为空，则为父节点(需要三叉链表)</br></br>如果是左孩子且右子树不为空，则为后序遍历左子树的最后一个结点|

      ***注：若不使用三叉链表则需要按指定顺序重新遍历来寻找前驱或后继***

### 1.3 树、森林、二叉树的转换

* 树 $\to$ 二叉树
  * 孩子兄弟表示法：左孩子右兄弟
* 二叉树 $\to$ 树
  * 按左孩子右兄弟逆序恢复即可
* 森林 $\to$ 二叉树
  * 每棵树的根结点视为同级的兄弟结点，按层次使用孩子兄弟表示法直接进行转换
* 二叉树 $\to$ 森林
  * 按左孩子右兄弟逆序恢复，同时与根节点同级的兄弟结点均作为森林中树的根结点

### 1.4 树的应用

* 哈夫曼树与哈夫曼编码
  * 概念
    * $结点的带权路径长度=根节点到结点的路径长度\times结点的权值$
    * $树的带权路径长度\text{WPL}=\sum^n_{i=1}{\big(叶结点的权值\times根节点到叶结点的路径长度\big)}$ 。其中 $n$ 为叶节点的个数
    * $哈夫曼树的加权平均长度=\dfrac{\text{WPL}}{\sum^n_{i=1}{叶结点的权值}}$ 。其中 $n$ 为叶节点的个数
    * 哈夫曼树：在有 $n$ 个叶子结点的二叉树中， $\text{WPL}$ 最小的树即为哈夫曼树。也称最优二叉树
  * 构建哈夫曼树
    * 初始化一个按权值升序为规则的优先队列。将所有结点入队
    * 每次出队前两个权值最小的结点，这两个结点将作为兄弟。生成一个新的结点，新结点的权值为这两个结点之和，同时将新节点作为这两个结点的双亲。最后将新节点入队
    * 重复上述操作，直至队空
  * 哈夫曼树性质
    * 哈夫曼树的结点总数为 $2 n-1$
      * 除最开始的两个结点外，其余每个结点加入时都会生成一个新的结点，因此结点数为 $2(n-2)+3=2 n-1$
    * 哈夫曼树中不存在度为 $1$ 的结点
    * 哈夫曼树不唯一，但 $\text{WPL}$ 唯一
    * 每个结点最终都会成为叶结点，且权值越小的结点离根结点越远
  * 哈夫曼编码
    * 哈夫曼树路径左 $0$ 右 $1$ ，即为从根节点到某个叶结点的哈夫曼编码
    * 哈夫曼编码属于可变长度编码，每个结点的编码长度不完全一致
    * 哈夫曼编码属于前缀编码，即没有任何一个结点的哈夫曼编码是另一个结点哈夫曼编码的前缀
    * 哈夫曼编码可用于压缩数据长度
* 并查集
  * 存储：`boss: list[int]`
    * `boss[i]`表示结点`i`双亲结点的下标，有如下关系

      $$
      boss[i]\begin{cases}
      <-1&, 根节点。树的结点数量=\left\lvert boss[i]\right\rvert\\
      =-1&, 初始的根节点\\
      \geq0&, 双亲结点的下标
      \end{cases}
      $$

    * 初始化：`def init((boss: list[int])`
  * 查：`def find(boss: list[int], node_idx: int)`
    * 嵌套查找到结点的最终根结点，即`boss[node_idx] < 0`的结点
    * 优化：压缩路径。每次查询完根节点后，将本次查询经过的所有结点的`boss`数组值均置为根节点下标`root_idx`。最终查询时间复杂度可以低至 $O(\alpha(n))\approx O(1)$
  * 并：`def union(boss: list[int], root_1: int, root_2: int)`
    * 提供`node_idx_1: int`与`node_idx_2: int`，将这两个结点所属集合连接成一个集合，即`union(boss, find(node_idx_1), find(node_idx_2))`
    * 优化：因为并操作时间复杂度为 $O(1)$ ，但查操作时间复杂度为 $O(h)，h$ 为树的高度。因此让小树并入大树，每次并的时候检查`boss[root]`的值，将结点数量少的小树的根节点指向结点数量多的大树的根节点，这样就不会增加树的高度。优化后的查操作时间复杂度为 $O(\lfloor\log_2{n}\rfloor+1)$

## 2 题目

* 5.1习题
  * 03(树的路径长度)
* 5.2习题
  * 03(树的性质)
  * 08(二叉树性质)
  * 16(完全二叉树结点个数)
  * 19(链式存储)
  * 25(完全二叉树结点个数)
  * 28(顺序存储)
* 5.3习题
  * 01(二叉树遍历)
  * 04(二叉树遍历)
  * 08(二叉树遍历)
  * 11(二叉树遍历)
  * 21(二叉树遍历)
  * 27(二叉树遍历、线索二叉树)
  * 28(二叉树遍历、线索二叉树)
  * 29(线索二叉树)
  * 31(二叉树遍历、线索二叉树)
  * 42(二叉树遍历)
* 5.4习题
  * 04(森林转二叉树结点个数)
  * 06(森林转二叉树结点个数)
  * 08(森林转二叉树空指针个数)
  * ***16(树转二叉树无右子树个数)***
* 5.5习题
  * 04(哈夫曼编码最大剩余数量)
  * 08(哈夫曼树带权路径长度)
  * 11(并查集集合个数)
  * 22(哈夫曼编码加权平均长度)
