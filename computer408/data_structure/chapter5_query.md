# 查找

## 1 知识点

* 查找表：用于查找的数据集合，由同类型的数据元素组成
  * 静态查找表：只查不改，适合顺序查找、折半查找、散列查找等
  * 动态查找表：既查也改，适合树形查找、散列查找
* 关键字：数据元素中唯一标识该元素的某个数据项的值
* 平均查找长度 $\text{ASL}$
  
  $$
  \text{ASL}=\sum^n_{i=1}{P_i C_i}
  $$

  其中，$n$ 为查找表的长度，$P_i$ 是查找第 $i$ 个数据元素的概率，通常认为每个数据元素被查找的概率相同，即 $P_i=\dfrac{1}{n}$。$C_i$ 是找到第 $i$ 个数据元素需要进行的比较次数

### 1.1 线性查找

* 顺序查找
  * 定义：从头到尾遍历对比
  * 优化
    * 有序化查找表，搭配判定树查找
    * 若被查找概率不等，可根据概率优化序列排序方式，使得 $\text{ASL}$ 最小
* 折半查找
  * 定义：适用于 ***有序*** 的 ***顺序表***
  * 判定树(本质为二叉排序树)
    * $\text{ASL}$
      * $\text{ASL}_{成功}=\dfrac{1}{n}\sum^n_{i=1}{结点n_i的比较次数}$。其中，比较次数包括等于号，即`查找成功的比较次数 = 根到成功结点的路径长度 + 1`。$n$ 为成功结点的个数
      * $\text{ASL}_{失败}=\dfrac{1}{n+1}\sum^{n+1}_{i=1}{结点n_i的比较次数}$。其中，比较次数不包括等于号，即`查找失败的比较次数 = 根到失败结点的路径长度 = 树高`。$n$ 为成功结点的个数

      ![二分判定树](../../resource/image/data_struct/chapter5_query_%E4%BA%8C%E5%88%86%E5%88%A4%E5%AE%9A%E6%A0%91.jpeg "二分判定树")
    * 性质

      根据如下规则下沉生成的判定树具有下列性质
      $$
      \begin{cases}
        \text{left}=0\\
        \text{right}=\text{len}(\text{sequence})-1\\
        \text{mid}=\Big\lfloor\dfrac{\text{left}+\text{right}}{2}\Big\rfloor
      \end{cases}
      $$

      * 判定树一定是平衡二叉树
      * 只有最下层可能不满
      * 右子树结点数 $-$ 左子树结点数 $=0$ 或 $1$
      * 有 $n$ 个成功结点，$n+1$ 个失败结点(正好使用了二叉树的 $n+1$ 个空指针)
      * 树高(不包含失败结点)为 $\lceil\log_2{(n+1)}\rceil$

        ![二分判定树生成](../../resource/image/data_struct/chapter5_query_%E4%BA%8C%E5%88%86%E5%88%A4%E5%AE%9A%E6%A0%91%E7%94%9F%E6%88%90.png "二分判定树生成")

* 分块查找(索引顺序查找)
  * 定义
    * 索引表：`Index(max_value: float, left: int, right: int)`。其中，`max_value`表示该块内最大的元素，`left, right`表示该块的左右区间
    * 查找表：`table: list[float]`
  * 流程
    * 首先使用顺序查找或折半查找在索引表中查找的元素所属的块
    * 在块中使用顺序查找找到具体元素
  * 性质
    * 块间有序，块内无序
  * $\text{ASL}$

      设有 $n$ 条记录，均匀分为 $b$ 块，每块有 $s$ 条记录，则 $\text{ASL}=\text{ASL}_{索引表}+\text{ASL}_{查找表}$
    * 索引表使用顺序查找：$\text{ASL}=\dfrac{b+1}{2}+\dfrac{s+1}{2}$。***其中，当 $s=\sqrt{n}$ 时，$\text{ASL}=\sqrt{n}+1$ 为最小值***
    * 索引表使用折半查找：$\text{ASL}=\lceil\log_2{(b+1)}\rceil+\dfrac{s+1}{2}$
    * 效率最快：$\text{ASL}=\lceil\log_2{(b+1)}\rceil+\lceil\log_2{(s+1)}\rceil$。其中 $b=s=\sqrt{n}$

### 1.2 树形查找

* 二叉排序树 $\text{BST}$
  * 定义：`左子树 < 根 < 右子树`，并且递归定义
  * 操作
    * 查找：`<`往左子树走，`>`往右子树走，`=`就是当前结点
    * 插入：找到对应的叶结点(插入前为`Null`)，将结点插入
    * 删除
      * 叶结点：直接删
      * 只有一个子树的分支结点：删除结点后将子树接上去即可
      * 有两个子树的分支结点
        * 方案 $1$：先将当前结点 $A$ 删除，随后取左子树最大的结点 $B$ (即中序遍历 $A$ 的前驱)放在 $A$ 的位置上，$B$ 的子树处理按“只有一个子树的分支结点”处理(因为中序遍历最大结点一定没有右子树)
        * 方案 $2$：先将当前结点 $A$ 删除，随后取右子树最小的结点 $B$ (即中序遍历 $A$ 的后继)放在 $A$ 的位置上，$B$ 的子树处理按“只有一个子树的分支结点”处理(因为中序遍历最小结点一定没有左子树)
  * 性质
    * 中序遍历二叉排序树的序列为有序序列
    * $\text{ASL}$ 计算同判定树
    * 平均时间复杂度为 $O(\log_2{n})$，最坏时间复杂度为 $O(n)$
* 平衡二叉树 $\text{AVL}$
  * 定义
    * 平衡二叉树：为了保证二叉排序树的查找效率，定义 ***左右子树高度差的绝对值不超过 $1$*** 的 ***二叉排序树*** 为平衡二叉树
    * 结点的平衡因子 $=$ 左子树高度 $-$ 右子树高度
    * 最小不平衡子树：以插入路径上离插入结点最近的且平衡因子绝对值 $>1$ 的结点为跟的子树
  * 操作
    * 查找
      * 同二叉排序树
    * 插入

        型号说明：在结点`A`的`X`孩子的`X`子树中发生插入导致失衡。其中，结点`A`为最小不平衡子树的根结点

        ***注意：每次调整操作均为原子操作，不可分割，必须完整执行***
      * $\text{LL}$ 型

        `B`变成根结点，`A`及其右子树整个变成`B`的右子树，原`B`的右子树变成`A`的左子树

        ![LL型](../../resource/image/data_struct/chapter5_query_AVL_LL.jpeg "LL型")
      * $\text{RR}$ 型

        `B`变成根结点，`A`及其左子树整个变成`B`的左子树，原`B`的左子树变成`A`的右子树

        ![RR型](../../resource/image/data_struct/chapter5_query_AVL_RR.jpeg "RR型")
      * $\text{LR}$ 型

        以`B`为跟的子树先对`C`做`RR`调整，以`A`为跟的子树再对`C`做`LL`调整

        ![LL型](../../resource/image/data_struct/chapter5_query_AVL_LR.jpeg "LR型")
      * $\text{RL}$ 型

        以`B`为跟的子树先对`C`做`LL`调整，以`A`为跟的子树再对`C`做`RR`调整

        ![LL型](../../resource/image/data_struct/chapter5_query_AVL_RL.jpeg "RL型")
    * 删除
      * 先删除目标结点，删除方法同二叉排序树
      * 若没有不平衡子树则完成删除。否则需找到最小不平衡子树，设结点`A`为最小不平衡子树的根结点
        * 设结点`B`为结点`A`的两个子树中高度最大的子树的根结点
        * 设结点`C`为结点`B`的两个子树中高度最大的子树的根结点
      * 根据`A`、`B`、`C`的排列类型确定是 $\text{LL},\text{RR},\text{LR},\text{RL}$ 中的哪一种，并进行对应操作
      * 操作完后观察 `A` 的所有祖先结点，观察是否出现失衡传递。若出现，重复上一步进行调整，直至整树平衡
  * 性质
    * 深度为 $h$ 的平衡二叉树的最少结点数 $n_h=n_{h-2}+n_{h-1}+1$。其中，$n_0=0,n_1=1$
      * ***所有非叶结点的平衡因子均为 $1\Leftrightarrow\text{AVL}$ 树结点最少***
    * 平衡二叉树的平均时间复杂度为 $O(\log_2{n})$
* 红黑树 $\text{RBT}$
  * 定义

    满足下列红黑性质的 ***二叉排序树*** 为红黑树
    * 左根右：`左子树 <br 根 <br 右子树`
    * 根叶黑：根结点与失败叶结点均是黑色的
    * 不红红：上下不存在两个相邻的红结点
    * 黑路同：对任意结点，从该结点到任意叶结点的简单路径上，所含黑结点的数量相同。黑结点的数量称为 **黑高**

    ![红黑树](../../resource/image/data_struct/chapter5_query_RBT.jpeg "红黑树")
  * 性质
    * 从根结点到任意叶结点的最长路径长度不超过最短路径长度的 $2$ 倍
    * 有 $n$ 个内部结点的红黑树高度 $h\leq2\log_2{(n+1)}$
    * 若根结点的黑高为 $h$，则至少有 $2^h-1$ 个内部结点
  * 操作
    * 查找
      * 同二叉排序树
    * 插入
      ![红黑树插入](../../resource/image/data_struct/chapter5_query_RBT_insert.png "红黑树插入")
    * 删除

      太难不考
* $\text{B}$ 树
  * 定义

    ***空树*** 或满足如下性质的 $m$ 叉树称为 $m$ 阶 $\text{B}$ 树
    * 根结点的子树数 $\in[2,m]$，关键字数 $\in[1,m-1]$
    * 其他结点的子树数 $\in[\lceil m/2\rceil,m]$，关键字数 $\in[\lceil m/2\rceil-1,m-1]$
    * 对任一结点，其左右子树高度相同
    * 结点内的关键字有序，`子树0 <br 关键字0 <br 子树1 <br 关键字1 <br 子树2...`

    ![5阶B树](../../resource/image/data_struct/chapter5_query_Btree.jpeg "5阶B树")
  * 性质
    * 含有 $n$ 个关键字的 $m$ 阶 $\text{B}$ 树高度满足 $\log_m{(n+1)}\leq h\leq\log_{\lceil m/2\rceil}{(\dfrac{n+1}{2})}+1$
      * 树最高时共有 $1+2(\lceil m/2\rceil^{h-1}-1)$ 个关键字
      * 树最矮时共有 $m^h-1$ 个关键字
    * 含有 $n$ 个关键字的 $m$ 阶 $\text{B}$ 树有 $n+1$ 个叶结点($n+1$ 种失败情况)
  * 操作
    * 查找
      * 同二叉排序树
    * 插入
      * 首先查找到新关键字应该在终端结点中的位置，并插入新关键字。若插入后该终端结点未超出数量上限，则完成插入。否则按如下方法处理
      * 将该终端结点的关键字按第 $\lceil m/2\rceil$ 个关键字分裂为左右两部分
        * 左部分保留在原先的终端结点不动
        * 第 $\lceil m/2\rceil$ 个关键字插入原终端结点的父结点。若原终端结点没有父结点(即为根结点)，则直接向上创造一个新结点作为父结点
        * 右部分成为新终端结点，并挂在原终端结点的父结点下
        * 检查父结点是否因为插入第 $\lceil m/2\rceil$ 个关键字导致超出数量上限。若是，则重复该分裂步骤，直至传导到根结点

        > 插入 $75$
        > ![插入75前](../../resource/image/data_struct/chapter5_query_Btree_insert_0.jpeg "插入75前")
        > 第 $1$ 次分裂：分裂出 $[60,70]$、$70\uparrow$、$[74,75]$
        >
        > ![第1次分裂](../../resource/image/data_struct/chapter5_query_Btree_insert_1.jpeg "第1次分裂")
        > 第 $2$ 次分裂：分裂出 $[49,73]$、$80\uparrow$、$[88,93]$
        >
        > ![第2次分裂](../../resource/image/data_struct/chapter5_query_Btree_insert_2.jpeg "第2次分裂")
    * 删除
      * 非终端结点
        * 先删除目标关键字
        * 再将终端结点中目标关键字的直接前驱或直接后继移到被删除目标关键字的位置，相当于转化为删除终端结点
          * 直接前驱：概念同线索二叉树，在目标关键字左指针的最右下
          * 直接后继：概念同线索二叉树，在目标关键字右指针的最左下
      * 终端结点
        * 删除目标关键字。若结点内关键字数量不低于下限则完成删除。否则按如下方法处理
        * 查看该终端结点的兄弟终端结点，是否在借出一个关键字后仍然不低于关键字下限
          * 右兄弟够借

            用目标关键字的后继、后继的后继去补
            > 删除 $38$
            ![删除38前](../../resource/image/data_struct/chapter5_query_Btree_del_terminal_0.jpeg "删除38前")
            > 用 $25$ 的后继 $49$ 补到原 $38$ 的位置，用 $25$ 后继的后继 $70$ 补到原 $49$ 的位置
            ![补](../../resource/image/data_struct/chapter5_query_Btree_del_terminal_2.jpeg "补")
            ![删除38后](../../resource/image/data_struct/chapter5_query_Btree_del_terminal_1.jpeg "删除38后")
          * 左兄弟够借

            用目标关键字的前驱、前驱的前驱去补
            > 删除 $90$
            ![删除90前](../../resource/image/data_struct/chapter5_query_Btree_del_terminal_3.jpeg "删除90前")
            > 用 $92$ 的前驱 $88$ 补到原 $90$ 的位置，用 $92$ 前驱的前驱 $87$ 补到原 $88$ 的位置
            ![补](../../resource/image/data_struct/chapter5_query_Btree_del_terminal_4.jpeg "补")
            ![删除90后](../../resource/image/data_struct/chapter5_query_Btree_del_terminal_5.jpeg "删除90后")
          * 左右兄弟都不够借

            左右终端结点与这两个结点夹着的关键字合并为一个结点。若父结点的关键字数量低于下限，则重复该合并步骤，直至传导到根结点
            > 删除 $49$
            > ![删除49前](../../resource/image/data_struct/chapter5_query_Btree_del_terminal_6.jpeg "删除90前")
            > 第 $1$ 次合并：合并 $[25]$、$[70]$、$[71,72]$
            >
            > ![第1次合并](../../resource/image/data_struct/chapter5_query_Btree_del_terminal_7.jpeg "第1次合并")
            > 第 $2$ 次合并：合并 $[73]$、$[82]$、$[87,93]$
            >
            > ![第2次合并](../../resource/image/data_struct/chapter5_query_Btree_del_terminal_8.jpeg "第2次合并")
* $\text{B}+$ 树
  * 定义

      满足如下性质的 $m$ 叉树称为 $\text{B}$ 树
    * 根结点的子树数 $\in[1,m]$，关键字数 $=$ 子树个数
      * 取 $1$ 时根结点同时为叶结点，即整个 $\text{B}+$ 树只有 $1$ 个结点
      * 非叶根节点的子树数 $\in[2,m]$
    * 分支结点的子树数 $\in[\lceil m/2\rceil,m]$，关键字数 $=$ 子树个数
    * 对任一结点，***关键字数 $=$ 子树个数(注意区别于 $B$ 树)***
    * 所有叶结点包含全部关键字及指向对应记录的指针，叶结点内关键字**有序**，相邻叶结点间**有序**连接。所有叶结点保持**总体有序**
    * 所有分支结点仅包含其各个子结点中 **关键字的最大值** 与指向子结点的指针

    ![4阶B+树](../../resource/image/data_struct/chapter5_query_B+tree.png "4阶B+树")
  * 性质
    * $\text{B}+$ 树支持在叶结点上顺序查找
  * 操作
    * 查找
      * 同分块查找：即使分支结点命中，也必须要查找到叶结点，因为查找目标是`记录`，只有叶结点才有指向`记录`的指针。总的来说，不论查找成功与否，都要查找到叶结点
      * 顺序查找：直接在叶结点上顺序查找
  * 与 $\text{B}$ 树对比

    |类别|$m$ 阶 $\text{B}$ 树|$m$ 阶 $\text{B+}$ 树|
    |:-:|:-:|:-:|
    |类比|二叉查找树的进化 $\to m$ 叉查找树|分块查找的进化 $\to$ 多级分块查找|
    |关键字</br>分叉|$n$ 个关键字对应 $n+1个$ 分叉(子树)|$n$ 个关键字对应 $n$ 个分叉|
    |结点信息|所有结点中都包含记录的信息|只有最下层叶子结点才包含记录的信息(可使树更矮)|
    |查找方式|不支持顺序查找。查找成功时，可能停在任何一层结点，查找速度“不稳定”|支持顺序查找。查找成功或失败都会到达最下一层结点，查找速度“稳定”|

    **相同点**：除根节点外，最少 $\lceil m/2\rceil$ 个分叉(确保结点不要太“空”)。任何一个结点的子树都要一样高(确保“绝对平衡”)

### 1.3 散列查找

* 定义
  * 散列表：又称哈希表，可以根据数据元素的关键字使用散列函数计算出在散列表中的存储地址
  * 散列函数：建立了`关键字 → 存储地址`的映射关系
  * 冲突：向散列表插入数据元素时，发现目标地址已经存储了其他数据元素，称为冲突
  * 同义词：不同的关键字通过散列函数映射到了同一个地址
* 构造散列函数

  |方法|散列地址公式|参数说明|适用场景|
  |:-:|:-:|:-:|:-:|
  |**除留余数法**|$H(x)=x\bmod p$|$p$ 是不超过散列表表长的最大质数|关键字为整数，比较通用|
  |**直接定址法**|$H(x)=a x+b$|$a,b$ 是任意常数|关键字分布较为连续，可映射为连续区间|
  |**数字分析法**|选取数码分布均匀的若干位作为地址|如手机号、身份证号等在不同位上出现概率不同的情况|关键字集合已知，且某些位分布较均匀|
  |**平方取中法**|取关键字平方结果的中间 $k$ 位|$k$ 的取值由具体情况决定|关键字的每位取值都不够均匀|

* 解决冲突
  * 拉链法
    * 定义
      * 散列表：`HashTable(element: list[float])`。其中，`element`是散列表中的每个元素，使用链表存储所有冲突的关键字
    * 操作
      * 插入

        先使用散列函数找到散列表中对应地址的链表，再对链表插入关键字
        > 表长 $13$ 的散列表，依次插入关键字 $[19,14,23,1,68,20,84,27,55,11,10,79]$
        ![散列表插入](../../resource/image/data_struct/chapter5_query_hash_insert.png "散列表插入")
      * 查找、删除

        先使用散列函数找到散列表中对应地址的链表，再在链表中顺序查找到关键字，选择删除
  * 开放地址法
    * 定义
      * 散列表：`HashTable(element: HashNode)`。其中，`element`是散列表中的每个元素
      * 散列表元素：`HashNode(key: float, is_del: bool)`。其中，`key`为关键字值，`is_del`表示该关键字是否逻辑删除
        * ***必须使用`is_del`对散列表进行逻辑删除标记，因为查找时需要保留探测路径，否则在查找时会因为遇到无关键字的物理空块而提前终止***
        * 可以定期物理删除那些被逻辑删除的关键字，重建散列表，将关键字回归到本来被逻辑删除的关键字所占据的位置，提高查找效率
    * 探测序列

      |方法|探测序列|是否完全覆盖|
      |:-:|:-:|:-:|
      |**线性探测法**|$d_i=0,1,2,\cdots,m-1$|最多 $m-1$ 次即可完全覆盖|
      |**平方探测法**|$d_i=0^2,1^2,-1^2,2^2,-2^2,\cdots,k^2,-k^2$</br>其中 $k\leq m/2$|仅当 $m=4 k+3(k\in N^*)$ 且 $m$ 为素数时才能完全覆盖|
      |**双散列探测法**|$d_i=i\cdot h(x)$</br>其中 $h(x)$ 为另一个散列函数|仅当 $h(x)$ 与 $m$ 互质时才能完全覆盖</br>**E.g.** 令 $m$ 为质数，$h(x)=m-(x\bmod m)$|
      |**伪随机探测法**|$d_i=\text{random}$</br>序列长度、序列元素预先由开发者自行设定|依赖初始设计|

      关键字 $x$ 的第 $i$ 次的散列地址 $H_i(x)=\big(H(x)+d_i\big)\bmod m$，其中 $d_i$ 为上表探测序列中的一种，$m$ 为散列表表长
    * 操作
      * 查找：先计算 $H_0$，若该地址为逻辑空(即`is_del == True`)且关键字匹配则查找成功。否则计算 $H_1,H_2,\cdots$，直至查找成功。若中途遇到无关键字的空块则停止查找，视为查找失败
      * 插入：查找到第一个无关键字的空块后将关键字写入，标记`is_del == False`
      * 删除：查找到目标关键字后将其删除，标记`is_del == True`
* 性能分析(以线性探测法为例)
  * $\text{ASL}_{成功}$

    单个元素的成功查找次数即为地址对比次数</br>
    ***即使中途遇到`is_del == True`的逻辑删除块，仍然需要继续往下探测，直至遇到物理空块才算查找失败！！！！！***

    ![ASL成功](../../resource/image/data_struct/chapter5_query_hash_ASL_success.jpeg "ASL成功")
  * $\text{ASL}_{失败}$

    ***以散列函数范围为准***，累加每个初始映射地址查找失败所需对比的次数</br>
    ***即使中途遇到`is_del == True`的逻辑删除块，仍然需要继续往下探测，直至遇到物理空块才算查找失败！！！！！***

    > 本题的散列函数可以映射到 $[0,12]$ 的地址范围，讨论这些地址的失败次数</br>
    > $key=0$：$0$ 处为空块，对比 $1$ 次失败</br>
    > $key=1$：$1,2,\cdots,11,12$ 处都不是空块，$13$ 处是空块，对比 $13$ 次失败</br>
    > $\cdots$</br>
    > $key=11$：$11,12$ 处不是空块，$13$ 处是空块，对比 $2$ 次失败</br>
    > $key=12$：$12$ 处不是空块，$13$ 处是空块，对比 $1$ 次失败
    >
    > ![ASL失败](../../resource/image/data_struct/chapter5_query_hash_ASL_fail.jpeg "ASL失败")
    >
    > 即使 $7$ 号块被逻辑删除了，在计算时仍然需要经过它，而不能判定为失败
    >
    > ![ASL逻辑删除](../../resource/image/data_struct/chapter5_query_hash_ASL_summary.png "ASL逻辑删除")
  * 装填因子：$\alpha=\dfrac{表中元素个数}{散列表长度}$
    * 装填因子越大越容易引发冲突，降低查找插入效率，使 $\text{ASL}$ 增大
    * ***$\text{ASL}$ 只与 $\alpha$ 直接相关，并不直接依赖散列表表长、散列表已有元素个数***
    * ***$\text{ASL}$ 受装填因子、散列函数、冲突解决策略(探测序列)的影响***
  * 聚集现象：多个初始散列地址不同的元素在处理冲突时争夺同一个地址
    * 聚集现象会降低查找插入效率，使 $\text{ASL}$ 增大
    * 线性探测法更容易出现聚集现象，可以换用其他探测序列将元素打散

## 2 题目

* 7.2 习题
  * 08(折半查找与二叉排序树)
  * 13(折半查找比较次数)
  * 19(折半查找最快速度)
  * ***23(折半查找判定树性质)***
* 7.3 习题
  * ***05(二叉排序树不可能序列)***
  * 08(二叉排序树最多比较次数)
  * ***09(二叉树遍历性质、卡特兰数)***
  * 13(平衡二叉树形态数量)
  * 17(红黑树性质、平衡二叉树性质)
  * ***31(平衡二叉树插入删除)***
* 7.4 习题
  * 05(B树叶结点与失败情况)
  * 07(B树最少关键字)
  * 08(B树高度范围)
  * ***10(B树查找次数)***
  * ***11(B树IO次数)***
  * ***19(B+树应用)***
* 7.5 习题
  * 04(堆积发生原因)
  * 10(冲突下一空位)
  * 22(ASL影响因素)
