# 哲学家进餐问题

在**哲学家就餐问题**中，

- **“互斥”条件**无法消除（筷子必须互斥使用）→ 不能改造成共享（不像 SPOOLing 把打印机虚拟化）；
- **“非抢占（不剥夺）”** 是系统设定（不能强行拿走哲学家手中的筷子）→ 通常不允许打破；
  
因此，**实际可行的解决方案主要集中在打破以下两个条件**：

1. **请求和保持（Hold and Wait）** → 用 **“全有或全无”策略**
2. **循环等待（Circular Wait）** → 用 **资源分级（编号小的优先）或一人反向**

下面我们用 **PV 操作（信号量）** 给出这两个条件对应的经典解决方案的**完整伪代码实现**。

---

## ✅ 方案一：打破“请求和保持”——全有或全无（引入 `room` 信号量）

> 思想：限制最多 **4 个哲学家同时尝试拿筷子**，确保至少一人能拿到两根，避免全部持有左筷等待右筷。

```c
#define N 5
semaphore chopstick[N] = {1, 1, 1, 1, 1};  // 每根筷子是一个信号量
semaphore room = 4;  // 最多允许4人同时尝试进餐

void philosopher(int i) {
    while (true) {
        think();

        P(room);           // 进入餐厅（申请“尝试吃饭”资格）
        P(chopstick[i]);       // 拿左筷子
        P(chopstick[(i+1)%N]); // 拿右筷子
        eat();
        V(chopstick[i]);     // 放左筷子
        V(chopstick[(i+1)%N]); // 放右筷子
        V(room);          // 离开餐厅

        think();
    }
}
```

✅ 打破了：**请求和保持**（因为最多4人竞争，不可能全部“持左等右”）  
⚠️ 注意：这不是 AND 信号量，而是通过限制并发尝试者数量来间接实现“全有或全无”

---

## ✅ 方案二：打破“循环等待”——资源分级（小号优先）

> 思想：规定所有哲学家必须先拿编号**小的**筷子，再拿编号**大的**，从而破坏环路等待。

```c
#define N 5
semaphore chopstick[N] = {1, 1, 1, 1, 1};

void philosopher(int i) {
    int left = i;
    int right = (i+1) % N;
    int first = (left < right) ? left : right;  // 小编号优先
    int second = (left > right) ? left : right; // 大编号后拿

    while (true) {
        think();

        P(chopstick[first]);   // 先拿小号筷子
        P(chopstick[second]);  // 再拿大号筷子
        eat();
        V(chopstick[second]);
        V(chopstick[first]);

        think();
    }
}
```

✅ 打破了：**循环等待**（所有人按编号顺序拿资源，无法形成环路）  
📌 例如：0号先0后1；1号先1后2；... 4号先0后4 → 没有循环依赖

---

## ✅ 方案二变体：一人反向拿筷（也破坏循环等待）

> 让最后一个哲学家（如 4 号）先拿右筷（0号），再拿左筷（4号），其余正常。

```c
#define N 5
semaphore chopstick[N] = {1, 1, 1, 1, 1};

void philosopher(int i) {
    while (true) {
        think();

        if (i != 4) {
            // 普通哲学家：先左后右
            P(chopstick[i]);
            P(chopstick[(i+1)%N]);
        } else {
            // 4号哲学家：先右后左（反向）
            P(chopstick[0]);        // 先拿右筷（0号）
            P(chopstick[4]);        // 再拿左筷（4号）
        }
        eat();
        V(chopstick[i]);
        V(chopstick[(i+1)%N]);

        think();
    }
}
```

✅ 同样打破了：**循环等待**（对称性被破坏，环路断裂）。本质上和方案二相同，都是先拿小号再拿大号

---

## ✅ 总结对比（PV 操作版）

| 方案 | 打破的条件 | 核心机制 | 信号量操作特点 |
|------|-----------|----------|----------------|
| **限制人数（room=4）** | 请求和保持 | 最多4人竞争 | `P(room)` 入场，`V(room)` 离场 |
| **资源分级（小号优先）** | 循环等待 | 统一拿筷顺序 | 按 `min(i, i+1)` 顺序 `P` |
| **一人反向** | 循环等待 | 破坏对称性 | 仅一人 `P` 顺序相反 |

如果破坏请求和保持，那么就需要像方案一一样在最外层 $\text{PV}$ 不超过 $n-1$ 的信号量，$n$ 为哲学家数量，通过限制最大人数使得始终至少有 $1$ 个人能完整执行；如果破坏循环等待，就不需要现在最大人数，但需要先取小号再取大号，但因为循环的性质，首尾两个人必定争抢同一个资源，这也间接满足了最多 $n-1$ 个人被同时服务（无论是获得服务还是等待服务）。⚠️ ***总结来说就是一定至少得有 $1$ 个人能完整执行***

在考试中如果要求“用 PV 操作解决哲学家就餐问题”，推荐：

1. **首选“资源分级”方案**：逻辑清晰、代码简洁、无额外信号量。
2. **次选“room=4”方案**：直观体现“打破请求和保持”。
3. **避免使用 AND 信号量**（除非题目允许），因不是所有系统支持。

📌 **一句话总结**：
> 在互斥和非抢占不可变的前提下，用 PV 操作解决哲学家问题，关键是：
>
> - 打破**请求和保持** → 用 `room` 限制并发尝试者；
> - 打破**循环等待** → 用**编号顺序**或**一人反向**统一拿筷顺序。
